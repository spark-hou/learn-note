(self.webpackChunklearn_note=self.webpackChunklearn_note||[]).push([[138],{8138:function(n,e,l){"use strict";l.r(e),l.d(e,{default:function(){return r}});var c=l(66252),f=(0,c.HX)("data-v-62b24860");(0,c.dD)("data-v-62b24860");var m={class:"WebInterview"},d={class:"g-container"},p=(0,c.Wm)("div",{class:"g-block"},null,-1),v=(0,c.Wm)("div",{class:"g-block"},null,-1),W=(0,c.Uk)("html"),h=(0,c.Uk)("css"),g=(0,c.Uk)("说一说BFC（块级格式化上下文）"),y=(0,c.Wm)("pre",null,"            BFC（块级格式化上下文）是 CSS 中的一个重要概念，它是一个独立的渲染区域，具有自己的布局规则和渲染规则。\n            BFC 的主要作用是控制盒子的布局以及盒子之间的关系，可以避免一些常见的布局问题。\n\n            BFC 的形成有以下几种情况：\n\n                根元素或包含根元素的元素；\n                浮动元素（float 不为 none）；\n                绝对定位元素（position 为 absolute 或 fixed）；\n                行内块元素（display 为 inline-block）；\n                表格单元格（display 为 table-cell）；\n                overflow 值不为 visible 的块级元素。\n\n            BFC 的特点有以下几个：\n\n                内部的盒子会在垂直方向上一个接一个地放置，相邻盒子的垂直距离由 margin 决定；\n                BFC 中的盒子不会与浮动元素重叠，而是会根据浮动元素的位置进行调整；\n                BFC 中的盒子可以包含浮动元素，即清除浮动；\n                BFC 中的盒子不会影响外部元素的布局，即不会受到外部元素的影响；\n                BFC 中的区域不会被浮动元素覆盖。\n\n            BFC 的应用有以下几种：\n\n                清除浮动：将包含浮动元素的容器设置为 BFC，可以避免容器高度塌陷的问题；\n                避免外边距重叠：将相邻的两个盒子分别设置为两个独立的 BFC，可以避免它们之间的外边距重叠问题；\n                实现多列布局：将多列容器设置为 BFC，可以避免多列之间的影响；\n                避免浮动元素遮盖文本：将包含浮动元素的容器设置为 BFC，可以避免浮动元素遮盖文本的问题；\n                实现自适应布局：将容器设置为 BFC，可以避免外部元素的影响，实现自适应布局。\n            ",-1),P=(0,c.Uk)("说一说盒模型？"),_=(0,c.Wm)("pre",null,"            在 CSS 样式表中，当多个选择器同时作用于同一个元素时，会出现样式冲突的问题，此时就需要确定样式的优先级。\n            CSS 样式的优先级由以下几个因素决定，按照优先级从高到低排序：\n\n            !important：使用 !important 标记的样式具有最高的优先级，会覆盖其他所有样式。\n\n            内联样式：在 HTML 元素上使用 style 属性设置的样式具有比其他样式更高的优先级，但比 !important 低。\n\n            ID 选择器：使用 ID 选择器（例如 #my-element）定义的样式具有比其他选择器更高的优先级。\n\n            类选择器、属性选择器、伪类选择器：使用类选择器、属性选择器（例如 [href]）或伪类选择器（例如 :hover）定义的样式具有比元素选择器更高的优先级。\n\n            元素选择器：使用元素选择器（例如 p、div）定义的样式具有比通用选择器和子选择器更低的优先级。\n\n            通用选择器、子选择器：使用通用选择器（*）或子选择器（例如 ul > li）定义的样式具有最低的优先级。\n            ",-1),b=(0,c.Uk)("说一说盒模型？"),j=(0,c.Wm)("pre",null,"\n            ",-1),k=(0,c.Uk)("js"),S=(0,c.Uk)(" 说一说JS数据类型有哪些,区别是什么？"),w=(0,c.Wm)("pre",null,"              基础类型（放在栈）：null，undefined，string，number，bigint，symbol，boolean\n              引用类型（放在堆）：object\n            ",-1),H=(0,c.Uk)("关于null和undefined"),U=(0,c.Wm)("pre",null,"              在 JavaScript 中，null 和 undefined 都表示一个没有值的状态，但它们有一些不同的特点和用途。\n\n              undefined：表示一个变量已经声明但没有被赋值，或者一个属性或数组元素不存在。例如：\n\n              let x; // 声明变量但没有赋值\n              console.log(x); // 输出 undefined\n              let obj = {};\n              console.log(obj.prop); // 输出 undefined\n\n              null：表示一个变量或属性被明确地赋值为 null，表示它们没有值。例如：\n\n              let x = null; // 赋值为 null\n              console.log(x); // 输出 null\n              let obj = { prop: null };\n              console.log(obj.prop); // 输出 null\n            ",-1),C=(0,c.Uk)("说一说你对闭包的理解？ "),x=(0,c.Wm)("pre",null,"              闭包（Closure）是指函数能够访问并使用在其定义作用域内的变量，即使这些变量在函数被调用时已经离开了作用域。\n              通俗地说，闭包就是在函数内部创建一个“私有空间”，其中可以定义私有变量和函数，并在函数外部访问这些变量和函数。\n              在 JavaScript 中，由于函数是一等公民，因此函数可以作为参数传递给另一个函数，或者作为返回值返回。\n              闭包通常用于实现以下功能：\n\n                  封装变量和函数，避免全局变量的污染和冲突。\n                  记忆函数执行结果，避免重复计算，提高性能。\n                  实现模块化，防止命名空间冲突，提高代码可维护性。\n\n              下面是一个简单的闭包例子：\n\n              function createCounter() {\n                let count = 0; // 私有变量\n\n                function counter() { // 内部函数\n                  count++; // 修改私有变量\n                  console.log(count);\n                }\n\n                return counter; // 返回内部函数\n              }\n\n              const counter = createCounter(); // 创建一个计数器\n              counter(); // 输出 1\n              counter(); // 输出 2\n              counter(); // 输出 3\n             ",-1),D=(0,c.Uk)("说一说promise是什么与使用方法？"),T=(0,c.Wm)("pre",null,"              Promise 是一种异步编程的解决方案，它是 ES6 引入的一个新的对象类型。\n              Promise 可以看作是一种容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。\n              Promise 对象代表一个异步操作的最终完成（或失败）及其结果值的表示。\n              Promise 对象有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\n              Promise 对象的状态改变只能从 pending 到 fulfilled 或者从 pending 到 rejected，一旦状态改变就不会再变。\n              状态改变后，Promise 对象会调用相应的回调函数，处理异步操作的结果。\n              Promise 的使用方法如下：\n\n              // 创建一个 Promise 对象\n              const promise = new Promise((resolve, reject) => {\n                // 异步操作，例如发送 HTTP 请求\n                // 如果请求成功，调用 resolve 并传递结果\n                // 如果请求失败，调用 reject 并传递错误信息\n              });\n\n              // 使用 then 方法处理 Promise 的结果\n              promise.then(result => {\n                // 处理成功的结果\n              }).catch(error => {\n                // 处理失败的结果\n              });\n\n              在上面的代码中，Promise 对象会执行传入的异步操作，并根据操作的结果调用 resolve 或 reject 方法。\n              使用 then 方法可以处理 Promise 对象成功的结果，使用 catch 方法可以处理 Promise 对象失败的结果。\n              Promise 还提供了一些常用的方法，例如：\n              Promise.all：将多个 Promise 对象组合成一个 Promise 对象，等待所有 Promise 对象都成功或有一个失败后返回结果。\n              Promise.race：将多个 Promise 对象组合成一个 Promise 对象，等待任何一个 Promise 对象成功或失败后返回结果。\n              Promise.resolve：将一个普通值或一个 Promise 对象转化为一个 Promise 对象，如果传入的是一个 Promise 对象，则直接返回该对象。\n              Promise.reject：将一个错误信息转化为一个 Promise 对象，直接返回该对象并调用 catch 方法处理错误信息。\n              Promise 对于处理异步操作非常方便，避免了回调地狱的问题，并且可以很方便地处理多个异步操作的结果。\n            ",-1),O=(0,c.Uk)("实现一个promise a+"),A=(0,c.Wm)("pre",null,"              // 定义 Promise 构造函数\n              function PromiseAplus(executor) {\n              // 定义 Promise 对象的状态和结果值\n              this.state = 'pending';\n              this.value = undefined;\n\n              // 定义 resolve 和 reject 函数\n              const resolve = (value) => {\n                if (this.state === 'pending') {\n                  this.state = 'fulfilled';\n                  this.value = value;\n                }\n              };\n\n              const reject = (reason) => {\n                if (this.state === 'pending') {\n                  this.state = 'rejected';\n                  this.value = reason;\n                }\n              };\n\n              // 执行 executor 函数\n              try {\n                executor(resolve, reject);\n              } catch (error) {\n                reject(error);\n              }\n              }\n\n              // 定义 then 方法\n              PromiseAplus.prototype.then = function (onFulfilled, onRejected) {\n              // 如果 onFulfilled 或 onRejected 不是函数，则将它们忽略\n              onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n              onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };\n\n              // 根据 Promise 对象的状态调用相应的回调函数\n              if (this.state === 'fulfilled') {\n                return new PromiseAplus((resolve, reject) => {\n                  try {\n                    const result = onFulfilled(this.value);\n                    if (result instanceof PromiseAplus) {\n                      result.then(resolve, reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n              }\n\n              if (this.state === 'rejected') {\n                return new PromiseAplus((resolve, reject) => {\n                  try {\n                    const result = onRejected(this.value);\n                    if (result instanceof PromiseAplus) {\n                      result.then(resolve, reject);\n                    } else {\n                      resolve(result);\n                    }\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n              }\n\n              if (this.state === 'pending') {\n                return new PromiseAplus((resolve, reject) => {\n                  try {\n                    const fulfilledCallback = (value) => {\n                      try {\n                        const result = onFulfilled(value);\n                        if (result instanceof PromiseAplus) {\n                          result.then(resolve, reject);\n                        } else {\n                          resolve(result);\n                        }\n                      } catch (error) {\n                        reject(error);\n                      }\n                    };\n\n                    const rejectedCallback = (reason) => {\n                      try {\n                        const result = onRejected(reason);\n                        if (result instanceof PromiseAplus) {\n                          result.then(resolve, reject);\n                        } else {\n                          resolve(result);\n                        }\n                      } catch (error) {\n                        reject(error);\n                      }\n                    };\n\n                    this.fulfilledCallbacks.push(fulfilledCallback);\n                    this.rejectedCallbacks.push(rejectedCallback);\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n              }\n              };\n            ",-1),F=(0,c.Uk)("说一说事件循环Event loop，宏任务与微任务"),J=(0,c.Wm)("pre",null,"              JavaScript 运行时包括一个主线程和一个消息队列，主线程执行同步代码，遇到异步任务会将它们添加到消息队列中。\n              异步任务完成后会被添加到消息队列的尾部。事件循环从消息队列中读取消息并将它们压入调用栈中执行。\n\n              在事件循环中，异步任务分为两种：宏任务和微任务。\n\n              宏任务：通常包括整体代码 script ，setTimeout ，setInterval 等异步任务。\n\n              微任务：通常包括 Promise 中的 then ，catch ，finally，Object.observe (已废弃) 等异步任务。\n\n              事件循环的执行过程如下：\n\n                  执行同步代码，将所有微任务添加到微任务队列中。\n\n                  执行当前宏任务，执行完后将该宏任务产生的所有微任务添加到微任务队列中。\n\n                  从微任务队列中取出所有任务，按照添加顺序执行。\n\n                  如果当前宏任务执行过程中产生了新的宏任务，将其添加到宏任务队列中。\n\n                  重复执行步骤 2~4，直到所有任务执行完毕。\n\n              下面是一个简单的示例，演示了宏任务和微任务的执行顺序：\n\n              console.log('start');\n\n              setTimeout(function() {\n                console.log('setTimeout');\n              }, 0);\n\n              new Promise(reslove=>{\n                console.log(\"define Promise\")\n              reslove()\n              },reject=>{\n                reject()\n              }).then(function() {\n                console.log('Promise');\n              });\n\n              console.log('end');\n\n              上面的代码中，我们使用 setTimeout 和 Promise 分别创建了一个宏任务和一个微任务。\n              在执行过程中，console.log('start') 和 console.log('end') 会被立即执行，\n              然后 Promise 的回调函数会被放入微任务队列，setTimeout 的回调函数会被放入宏任务队列。\n              接着，JavaScript 引擎会执行所有微任务，即先输出 Promise，然后才会执行下一个宏任务，即输出 setTimeout。\n\n              start\n              define Promise\n              end\n              Promise\n              setTimeout\n            ",-1),M=(0,c.Uk)("说一说JavaScript有几种方法判断变量的类型？"),I=(0,c.Wm)("pre",null,'              typeof：用于检查一个变量的类型，返回一个字符串，包括 "undefined"、"number"、"string"、"boolean"、"function"、"object" 和 "symbol"。\n              但是 typeof 无法区分对象和 null，且对于引用类型来说，返回值只有 "object" 和 "function" 两种，不够准确。\n\n              instanceof：用于判断一个对象是否属于某个类（构造函数），如果是，则返回 true，否则返回 false。\n              但是 instanceof 无法检测基本类型的值，也无法检测原始类型值的具体类型。\n\n              Object.prototype.toString：可以返回对象的具体类型，包括 "[object Object]"、"[object Array]"、"[object Date]" 等。\n              该方法可用于检测任意值的类型，但需要注意在跨 iframe 或 window 时可能会失效。\n\n              Array.isArray：用于判断一个值是否为数组类型，返回一个布尔值。该方法只能检测数组类型，不能检测其他类型的值。\n\n              typeof 与 instanceof 的结合：对于引用类型，可以先使用 typeof 判断是否为 "object"，然后使用 instanceof 判断是否属于某个具体的对象类型。\n            ',-1),B=(0,c.Uk)("说一说JS实现异步的方法？"),R=(0,c.Wm)("pre",null,"              回调函数：通过将回调函数作为参数传递给异步函数，当异步函数执行完成后调用回调函数。\n              回调函数是实现异步编程的最基本方法，但可能会导致回调地狱问题，可读性差。\n\n              Promise：Promise 是一种用于处理异步操作的对象，它有三个状态：Pending（进行中）、Resolved（已完成）和Rejected（已失败）。\n              通过 Promise 可以链式调用 then 方法，从而避免了回调地狱问题，可读性更好。\n\n              async/await：async/await 是 ECMAScript 2017 标准引入的语法糖，它基于 Promise 实现，并且使得异步操作的代码看起来像是同步的。\n              async 函数返回一个 Promise 对象，其中的 await 关键字可以暂停函数的执行，直到 Promise 对象的状态变为 resolved 或 rejected，\n              从而实现异步操作。\n\n              事件监听器：通过给异步操作添加事件监听器，当异步操作完成时触发事件，并执行相应的回调函数。这种方式适用于需要多次异步操作的场景，\n              比如网络请求等。\n\n              发布订阅模式：通过发布-订阅模式，将异步操作的结果传递给订阅者，从而实现异步编程。该模式通常使用第三方库实现，比如 RxJS。\n            ",-1),V=(0,c.Uk)("说一说数组去重都有哪些方法？"),$=(0,c.Wm)("pre",null,"              在 JavaScript 中，有多种方法可以对数组进行去重，常见的包括以下几种：\n\n              利用 Set 数据结构进行去重：使用 Set 数据结构可以很方便地对数组进行去重，因为 Set 不会存储重复的值。\n              可以将数组作为 Set 构造函数的参数，然后将 Set 转换为数组即可。\n\n              const arr = [1, 2, 2, 3, 3, 4];\n              const newArr = [...new Set(arr)];\n              console.log(newArr); // [1, 2, 3, 4]\n\n              利用 indexOf 进行去重：遍历原数组，如果新数组中不存在该元素，则将其添加到新数组中。\n\n              const arr = [1, 2, 2, 3, 3, 4];\n              const newArr = [];\n              for (let i = 0; i < arr.length; i++) {\n                if (newArr.indexOf(arr[i]) === -1) {\n                  newArr.push(arr[i]);\n                }\n              }\n              console.log(newArr); // [1, 2, 3, 4]\n\n              利用 includes 进行去重：类似 indexOf 方法，只是使用 includes 方法判断是否存在该元素。\n\n              const arr = [1, 2, 2, 3, 3, 4];\n              const newArr = [];\n              for (let i = 0; i < arr.length; i++) {\n                if (!newArr.includes(arr[i])) {\n                  newArr.push(arr[i]);\n                }\n              }\n              console.log(newArr); // [1, 2, 3, 4]\n\n              利用 filter 进行去重：利用 filter 方法进行去重，判断新数组中是否已经包含该元素，如果包含则过滤掉。\n\n              const arr = [1, 2, 2, 3, 3, 4];\n              const newArr = arr.filter((item, index, self) => {\n                return self.indexOf(item) === index;\n              });\n              console.log(newArr); // [1, 2, 3, 4]\n            ",-1),L=(0,c.Uk)("说一说call apply bind的作用和区别？"),E=(0,c.Wm)("pre",null,"              call、apply 和 bind 都是 JavaScript 中用于绑定函数执行上下文的方法。\n\n              它们的共同点是都可以用来改变函数内部的 this 指向。具体来说：\n              call 和 apply 都可以指定函数执行时的 this 值，并且可以传递参数给函数。\n              call 的参数是一个个传递的，例如 func.call(obj, arg1, arg2, ...)。\n              apply 的参数是一个数组，例如 func.apply(obj, [arg1, arg2, ...])。\n              bind 则是创建一个新函数，该函数的 this 值被绑定到指定的对象，但是并不会立即执行该函数，而是返回一个新函数。\n              返回的新函数可以在之后的任意时间被调用，并且保持绑定的 this 值和参数。\n\n              下面是一个使用 call、apply 和 bind 的示例：\n              const obj = {\n                name: 'John',\n                age: 30,\n              };\n\n              function sayHello(greeting) {\n                console.log(`${greeting}, my name is ${this.name}, and I'm ${this.age} years old.`);\n              }\n\n              // 使用 call 方法调用函数，并传递参数\n              sayHello.call(obj, 'Hello');\n\n              // 使用 apply 方法调用函数，并传递参数\n              sayHello.apply(obj, ['Hello']);\n\n              // 使用 bind 方法创建新的函数，并传递参数\n              const boundFunction = sayHello.bind(obj, 'Hello');\n              boundFunction();\n\n              需要注意的是，call、apply 和 bind 的区别在于它们的返回值和执行时机不同。\n              call 和 apply 直接调用函数并立即执行，而 bind 则返回一个新的函数并不会立即执行，需要手动调用。\n            ",-1),N=(0,c.Uk)("说一说this指向（普通函数、箭头函数）？"),G=(0,c.Wm)("pre",null,"              在 JavaScript 中，this 关键字指向当前执行上下文中的对象，具体的指向方式取决于函数的调用方式和函数本身的定义方式。\n\n              对于普通函数（即函数声明或函数表达式定义的函数），this 的值是在函数被调用时确定的，取决于调用方式。常见的调用方式有以下几种：\n\n              作为函数调用：此时 this 指向全局对象（在浏览器中是 window，在 Node.js 中是 global）。\n              作为方法调用：此时 this 指向调用该方法的对象。\n              使用 call、apply 或 bind 绑定上下文后调用：此时 this 指向被绑定的对象。\n              作为构造函数调用：此时 this 指向新创建的对象。\n              使用箭头函数调用：此时 this 指向箭头函数定义时的上下文，而不是执行时的上下文。箭头函数的 this 值不会受到上面这些调用方式的影响。\n\n              下面是一些示例：\n              function Person(name, age) {\n                this.name = name;\n                this.age = age;\n              }\n\n              Person.prototype.sayHello = function() {\n                console.log(`Hello, my name is ${this.name}, and I'm ${this.age} years old.`);\n              };\n\n              // 作为函数调用\n              function greet() {\n                console.log(`Hello, ${this}`);\n              }\n              greet(); // 输出：Hello, [object Window]\n\n              // 作为方法调用\n              const person = new Person('John', 30);\n              person.sayHello(); // 输出：Hello, my name is John, and I'm 30 years old.\n\n              // 使用 call 绑定上下文后调用\n              const otherPerson = new Person('Jane', 25);\n              person.sayHello.call(otherPerson); // 输出：Hello, my name is Jane, and I'm 25 years old.\n\n              // 作为构造函数调用\n              const newPerson = new Person('Bob', 20);\n              newPerson.sayHello(); // 输出：Hello, my name is Bob, and I'm 20 years old.\n\n              // 使用箭头函数调用\n              const obj = {\n                name: 'Alice',\n                age: 35,\n                sayHello: () => {\n                  console.log(`Hello, my name is ${this.name}, and I'm ${this.age} years old.`);\n                },\n              };\n              obj.sayHello(); // 输出：Hello, my name is undefined, and I'm undefined years old.\n\n              需要注意的是，在箭头函数中使用 this 时需要格外小心，因为它不会受到调用方式的影响，可能会产生意想不到的结果。\n              在大多数情况下，最好使用普通函数来避免这些问题。\n\n            ",-1),X=(0,c.Uk)("说一说JS变量提升？"),Z=(0,c.Wm)("pre",null,"              具体来说，JavaScript 中的变量提升分为两种：函数提升和变量提升。\n              函数提升指的是函数声明被提升到当前作用域的顶部，而变量提升指的是变量的声明被提升到当前作用域的顶部，\n              但是赋值操作不会被提升。变量提升只会提升声明部分，不会提升赋值部分，因此在赋值之前访问变量会得到 undefined。\n\n              console.log(a); // 输出：undefined\n              var a = 1;\n\n              foo(); // 输出：Hello, world!\n              function foo() {\n                console.log('Hello, world!');\n              }\n\n              bar(); // 报错：TypeError: bar is not a function\n              var bar = function() {\n                console.log('Hello, world!');\n              };\n            ",-1),q=(0,c.Uk)("说一说map 和 forEach 的区别？"),z=(0,c.Wm)("pre",null,"              map 和 forEach 都是 JavaScript 中常用的数组迭代方法，它们的主要区别在于返回值和对原数组的影响。\n              forEach 方法会对数组中的每个元素执行一次提供的函数，但它没有返回值，也不会改变原数组。\n              示例代码如下：\n\n              const arr = [1, 2, 3];\n              arr.forEach((item, index) => {\n                console.log(`Index ${index}: ${item}`);\n              });\n              // 输出：\n              // Index 0: 1\n              // Index 1: 2\n              // Index 2: 3\n\n              map 方法会对数组中的每个元素执行一次提供的函数，并将每次函数调用的结果存储到一个新数组中，最终返回该新数组。\n              示例代码如下：\n              const arr = [1, 2, 3];\n              const newArr = arr.map((item, index) => {\n                return item * 2;\n              });\n              console.log(newArr); // 输出 [2, 4, 6]\n\n\n            ",-1),K=(0,c.Uk)("vue"),Q=(0,c.Uk)("说一说Vue2.0 双向绑定的原理与缺陷？"),Y=(0,c.Wm)("pre",null,"              Vue2.0 中的双向数据绑定是通过数据劫持结合发布订阅模式实现的。\n              具体来说，当 Vue 实例化时，会对数据对象进行递归遍历，对每个属性都通过 Object.defineProperty 方法进行劫持，\n              将属性的 getter 和 setter 重写，这样当属性被访问或修改时，就可以触发相应的 getter 和 setter，\n              通过发布订阅模式来通知依赖的 Watcher 更新视图。\n              双向绑定的实现原理中，主要依赖于 Object.defineProperty 方法对属性进行劫持，\n              通过 getter 和 setter 来监听属性的变化，并且通过发布订阅模式来通知 Watcher 更新视图。\n              双向绑定让开发者能够更方便地进行数据绑定，避免了手动操作 DOM，提高了开发效率。\n              不过，Vue2.0 双向绑定也存在一些缺陷，主要包括：\n              对象属性的监听问题：由于 Vue2.0 的双向绑定是基于 Object.defineProperty 实现的，\n              当对象属性的值为对象时，需要对其进行递归劫持，这会导致性能问题，同时也会带来其他一些问题。\n\n              数组操作的限制：由于数组的变化不会触发 setter，Vue2.0 中对于数组变化的监听需要通过重写数组的方法\n              （如 push、pop、shift、unshift、splice、sort、reverse）来实现，这会带来额外的开发成本和一些限制。\n\n              深度监听的性能问题：当数据对象嵌套层级很深时，监听所有属性的变化会导致性能问题，\n              这时候可以使用 watch 选项或者 computed 计算属性来进行优化。\n            ",-1),nn=(0,c.Uk)("说一说Vue3.0 实现数据双向绑定的方法 ？"),en=(0,c.Wm)("pre",null,"              Vue3.0 采用了 Proxy 对象来实现数据双向绑定，与 Vue2.0 的双向绑定方式（Object.defineProperty）相比，有以下优点：\n\n              Proxy 可以监听对象的任意属性，而 Object.defineProperty 只能监听对象已有的属性。\n\n              Proxy 可以监听数组的变化，而 Object.defineProperty 不行。\n\n              Proxy 可以直接监听 Map 和 Set 类型的数据变化，而 Object.defineProperty 不支持。\n\n              下面是使用 Proxy 实现数据双向绑定的代码示例\n              let data = { message: 'hello world' };\n\n              let reactiveData = new Proxy(data, {\n                get(target, key) {\n                  console.log(`读取 ${key} 属性`);\n                  return Reflect.get(target, key);\n                },\n                set(target, key, value) {\n                  console.log(`设置 ${key} 属性为 ${value}`);\n                  return Reflect.set(target, key, value);\n                }\n              });\n\n              reactiveData.message = 'hello Vue3.0';\n              console.log(reactiveData.message);\n            ",-1),ln=(0,c.Uk)("说一下Diff算法？"),tn=(0,c.Wm)("pre",null,"              Diff算法是前端框架（如React、Vue等）用于高效更新视图的核心算法之一。\n              Diff算法会比较新旧两棵虚拟DOM树的差异，并将差异应用到实际的DOM树上，从而实现局部更新视图。\n\n              Diff算法的基本思路是通过比较新旧两棵虚拟DOM树，找出其差异并进行局部更新，而不是全量更新整个DOM树。\n              为了能够高效地找出差异，Diff算法会采用一些优化策略，例如：\n\n                  对比相同类型的节点，直接更新其属性值，不用重新创建节点。\n\n                  对比列表时，采用“key”值进行优化，只更新列表中发生变化的项，而不是全部重新渲染。\n\n                  在对比时采用“双指针”算法，对比过程中，新旧节点的指针会同时向后移动，从而减少比较的次数。\n\n              总之，Diff算法通过比较新旧虚拟DOM树的差异，以最小的代价来更新DOM树，从而实现高效的视图更新。\n              在前端框架中广泛应用，能够大大提高应用的性能和用户体验。\n            ",-1),rn=(0,c.Uk)("说一说 vue 的 keep-alive ？"),on=(0,c.Wm)("pre",null,"              在 Vue 中，使用 keep-alive 组件可以将被包含的组件缓存起来，不会被销毁，以便于下一次需要时直接从缓存中读取，从而提高应用性能。\n\n              keep-alive 组件有以下几个属性：\n\n                  include：用于指定需要缓存的组件名称，可以是一个字符串或一个正则表达式。\n                  exclude：用于指定不需要缓存的组件名称，可以是一个字符串或一个正则表达式。\n                  max：用于指定缓存的组件数量，当缓存的组件数量超过 max 时，会按照 LRU 策略进行缓存淘汰。\n\n              当 keep-alive 组件包含一个组件时，该组件的生命周期钩子函数会发生变化，具体如下：\n\n                  activated：在被包含的组件被激活时调用，此时组件状态为活动状态，可进行数据加载等操作。\n                  deactivated：在被包含的组件被停用时调用，此时组件状态为非活动状态，可进行一些清理操作。\n\n              使用 keep-alive 可以大大提高组件的复用性，节约组件的渲染开销，提高应用性能。在一些需要频繁切换的页面（如标签页等）中，可以将 keep-alive 与路由组件结合使用，实现更佳的缓存效果。\n            ",-1),un=(0,c.Uk)("浏览器"),an=(0,c.Uk)("说一说cookie sessionStorage localStorage 区别？"),sn=(0,c.Wm)("pre",null,"              cookie：小 4kb 发请求自动带cookie\n              sessionStorage：大 5M 单次会话存在\n              localStorage：大 5M 长期\n            ",-1),cn=(0,c.Uk)("说一说跨域是什么？如何解决跨域问题？"),fn=(0,c.Wm)("pre",null,"              跨域：当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了。\n              跨域限制的原因：浏览器为了保证网页的安全，出的同源协议策略。\n              跨域解决方案:\n              后端设置允许跨域\n              nginx，node代理\n              jsonp\n              postmessage\n            ",-1),mn=(0,c.Uk)("说一下浏览器输入URL发生了什么？"),dn=(0,c.Wm)("pre",null,"              URL解析：浏览器首先解析您输入的URL。这个过程将URL分解成几个组成部分，包括协议（例如HTTP或HTTPS），主机名和路径等。\n\n              DNS解析：一旦浏览器知道了主机名，它将使用DNS解析来查找IP地址。DNS服务器是一组全球分布的计算机，它们负责将主机名转换为与之关联的IP地址。\n\n              服务器连接：一旦浏览器知道了IP地址，它将尝试与服务器建立连接。如果您使用的是HTTPS协议，则还需要进行SSL握手以建立安全连接。\n\n              请求处理：一旦连接建立，浏览器将向服务器发送一个HTTP请求。该请求包括与资源相关的详细信息，\n              例如请求的资源类型，请求方法（例如GET或POST）以及其他相关信息。\n\n              服务器响应：一旦服务器收到请求，它将查找请求的资源并生成一个响应。响应包括与资源相关的详细信息，例如响应状态码，响应头和响应正文（即请求的资源）。\n\n              资源加载：一旦浏览器接收到响应，它将开始加载响应的资源。这可能包括HTML、CSS、JavaScript文件和其他媒体文件。\n\n              渲染页面：一旦所有资源加载完成，浏览器将开始渲染页面。这包括将HTML解析为DOM树、解析CSS并构建渲染树以及在屏幕上绘制渲染树。\n            ",-1),pn=(0,c.Uk)("说一下重绘、重排区别如何避免？"),vn=(0,c.Wm)("pre",null,"              在网页渲染的过程中，浏览器会进行重排（reflow）和重绘（repaint）操作，这两个操作会消耗较多的计算资源和时间，影响页面的性能和响应速度。因此，我们需要尽可能地避免重绘和重排的发生。\n\n              重排和重绘的区别：\n\n                  重排：当页面中的元素发生位置、尺寸、布局等变化时，浏览器需要重新计算元素的位置和大小，然后进行页面的重新排版和布局，这个过程就是重排。\n\n                  重绘：当页面中的元素发生样式的变化时，浏览器需要重新绘制元素的外观，也就是重新计算元素的样式和绘制过程，这个过程就是重绘。\n\n              如何避免重绘和重排：\n\n                  避免频繁操作DOM：DOM操作是导致页面重排和重绘的主要原因之一，因此尽量避免频繁操作DOM元素。\n\n                  批量修改样式：通过修改元素的class属性，一次性修改多个元素的样式，可以避免浏览器频繁重绘的问题。\n\n                  使用文档片段（DocumentFragment）：在插入大量元素时，使用文档片段可以避免频繁的DOM操作和页面重排。\n\n                  避免触发布局属性：布局属性包括offsetTop、offsetLeft、offsetWidth、offsetHeight、scrollWidth、scrollHeight、clientWidth、clientHeight等，它们会导致浏览器进行页面重排和重绘，因此应该尽量避免使用这些属性。\n\n                  减少重排影响范围：通过将需要频繁操作的元素单独放到一个div中，可以减小重排和重绘的影响范围。\n\n              总之，避免重排和重绘需要从设计、开发和优化等多个方面入手，需要综合考虑页面的结构、样式、交互等多个因素，以达到最佳的性能和用户体验。\n            ",-1),Wn=(0,c.Uk)("进阶"),hn=(0,c.Uk)("说一说前端性能优化手段？"),gn=(0,c.Wm)("pre",null,"              减少 HTTP 请求：减少页面中的资源数量，如脚本、样式表、图像等，可以显著减少 HTTP 请求的数量，从而加快页面加载速度。\n\n              压缩资源：压缩 HTML、CSS 和 JavaScript 文件可以减小它们的大小，从而减少页面的下载时间。\n\n              使用缓存：使用浏览器缓存来存储页面的静态资源，可以减少对服务器的请求次数，提高页面的响应速度。\n\n              使用 CDNs：使用内容分发网络（CDN）可以将静态资源分发到多个服务器，从而加快资源的加载速度。\n\n              优化图片：优化图片的格式、大小和质量可以减少它们的大小，从而减少它们的下载时间。\n\n              延迟加载：延迟加载非必要资源，如图片和视频，可以减少页面的下载时间，从而提高页面的响应速度。\n\n              减少重绘和回流：通过减少 DOM 操作和使用 CSS 动画，可以减少浏览器的重绘和回流操作，从而提高页面的性能。\n\n              懒加载：使用懒加载技术可以延迟加载页面中的某些资源，只有当用户滚动到它们时才会加载它们，从而提高页面的响应速度。\n\n              使用最新的浏览器：使用最新的浏览器可以享受更快的性能和更好的用户体验，因为它们通常包含更多的优化和改进。\n\n              去除不必要的插件和库：只使用必要的插件和库可以减少页面的加载时间和响应时间，提高页面性能。\n            ",-1),yn=(0,c.Uk)("说一说性能优化有哪些性能指标，如何量化？"),Pn=(0,c.Wm)("pre",null,"              性能优化的目标是提高应用程序的性能，从用户角度来看，性能指标可以分为以下几种：\n\n                  页面加载时间：页面加载时间是指从用户请求页面到页面完全加载完成所需的时间。\n                  通常通过网络请求和响应时间、资源下载时间、DOM 渲染时间等来计算。\n\n                  首次渲染时间（First Contentful Paint）：首次渲染时间是指从用户请求页面到页面首次显示内容所需的时间。\n                  通常以页面开始渲染的时间作为起点，直到页面显示第一个文本、图像或 SVG。\n\n                  可交互时间（Time to Interactive）：可交互时间是指用户可以在页面上进行交互的时间，例如点击链接、按钮等。\n                  通常指浏览器完成页面加载并响应用户输入的时间。\n\n                  页面卸载时间：页面卸载时间是指用户从页面离开到页面卸载完成所需的时间。通常是指页面完成所有资源的卸载和清理工作的时间。\n\n                  错误率：错误率是指应用程序在运行过程中发生错误的比率。这些错误可能包括 JavaScript 错误、资源加载失败等。\n\n              这些性能指标可以通过一系列工具和技术来量化和优化，如使用浏览器的开发者工具来分析页面加载时间和性能瓶颈，\n              使用性能测试工具来评估应用程序的性能，并对代码进行优化，使用监控工具来实时监控应用程序的性能并及时发现问题等等。\n              另外，也可以通过将这些指标与业务指标结合起来，来评估应用程序的整体性能和用户体验。\n\n            ",-1);(0,c.Cn)();var e=f(function(n,e,l,t,r,o){var u=(0,c.up)("a-page-header"),i=(0,c.up)("a-typography-title"),a=(0,c.up)("a-typography-text"),s=(0,c.up)("a-typography-paragraph");return(0,c.wg)(),(0,c.j4)("div",m,[(0,c.Wm)("div",d,[(0,c.Wm)(u,{id:"Top",style:{border:"1px solid rgb(235, 237, 240)"},title:n.title,onBack:n.backUp},null,8,["title","onBack"]),p,v,(0,c.Wm)(i,{level:2},{default:f(function(){return[W]}),_:1}),(0,c.Wm)(i,{level:2},{default:f(function(){return[h]}),_:1}),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[g]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[y]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[P]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[_]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[b]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[j]}),_:1})]}),_:1})]),(0,c.Wm)(i,{level:2},{default:f(function(){return[k]}),_:1}),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[S]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[w]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[H]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[U]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[C]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[x]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[D]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[T]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[O]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[A]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[F]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[J]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[M]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[I]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[B]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[R]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[V]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[$]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[L]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[E]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[N]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[G]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[X]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[Z]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[q]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[z]}),_:1})]}),_:1})]),(0,c.Wm)(i,{level:2},{default:f(function(){return[K]}),_:1}),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[Q]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[Y]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[nn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[en]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[ln]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[tn]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[rn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[on]}),_:1})]}),_:1})]),(0,c.Wm)(i,{level:2},{default:f(function(){return[un]}),_:1}),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[an]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[sn]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[cn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[fn]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[mn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[dn]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[pn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[vn]}),_:1})]}),_:1})]),(0,c.Wm)(i,{level:2},{default:f(function(){return[Wn]}),_:1}),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[hn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[gn]}),_:1})]}),_:1})]),(0,c.Wm)("div",null,[(0,c.Wm)(i,{level:4},{default:f(function(){return[yn]}),_:1}),(0,c.Wm)(s,null,{default:f(function(){return[(0,c.Wm)(a,null,{default:f(function(){return[Pn]}),_:1})]}),_:1})])])])}),t=l(42119),l=(0,c.aZ)({name:"WebInterview",setup:function(){var n={title:"前端面试题"},e=(0,t.tv)();return n.backUp=function(){e.back()},n}});l.render=e,l.__scopeId="data-v-62b24860";var r=l}}]);